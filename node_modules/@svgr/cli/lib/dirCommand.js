"use strict";

exports.__esModule = true;
exports.isCompilable = isCompilable;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _outputFileSync = _interopRequireDefault(require("output-file-sync"));

var _recursiveReaddir = _interopRequireDefault(require("recursive-readdir"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function rename(relative, ext, filenameCase) {
  const relativePath = _path.default.parse(relative);

  relativePath.ext = `.${ext}`;
  relativePath.base = null;
  relativePath.name = (0, _util.transformFilename)(relativePath.name, filenameCase);
  return _path.default.format(relativePath);
}

const COMPILABLE_EXTENSIONS = ['.svg', '.SVG'];

function isCompilable(filename) {
  const ext = _path.default.extname(filename);

  return COMPILABLE_EXTENSIONS.includes(ext);
}

async function dirCommand(program, filenames, _ref) {
  let {
    ext = 'js',
    filenameCase = _util.CASE.PASCAL
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, ["ext", "filenameCase"]);

  async function write(src, relative) {
    if (!isCompilable(relative)) return false;
    relative = rename(relative, ext, filenameCase);

    const dest = _path.default.resolve(program.outDir, relative);

    const code = await (0, _util.convertFile)(src, options);
    (0, _outputFileSync.default)(dest, code);
    process.stdout.write(`${src} -> ${_path.default.relative(process.cwd(), dest)}\n`);
    return true;
  }

  async function handle(filename) {
    const stats = await (0, _util.stat)(filename);

    if (stats.isDirectory(filename)) {
      const dirname = filename;
      const files = await (0, _recursiveReaddir.default)(dirname);
      await Promise.all(files.map(async _filename => {
        const relative = _path.default.relative(dirname, _filename);

        return write(_filename, relative);
      }));
    } else {
      await write(filename, filename);
    }
  }

  await Promise.all(filenames.map(handle));
}

var _default = dirCommand;
exports.default = _default;